<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring boot 集成Jsp]]></title>
    <url>%2Fblog%2F502.html</url>
    <content type="text"><![CDATA[前言上一篇介绍了Spring Boot中使用如何使用durid，这篇文章将介绍如何整合jsp进行web开发 项目结构首先在src/main 下新建目录：webapp/WEB-INF/view 用于存放jsp文件，项目的静态资源统一放在resources的static下面，初始的项目结构如下 引入依赖1234567891011121314151617&lt;!--WEB支持--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--jsp页面使用jstl标签--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--内置tocat对Jsp支持的依赖，用于编译Jsp--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;/dependency&gt; 使用内嵌的tomcat容器来运行的话只要这3个就好了,如果需要使用外部容器允许，需要额外配置，稍后会讲解 配置application.properties12345#jsp 文件存放的路径spring.mvc.view.prefix: /WEB-INF/view/#文件后缀spring.mvc.view.suffix: .jsp 编写相应文件编写jsp文件在view目录下创建index.jsp1234567891011&lt;%@ page contentType="text/html; charset=utf-8" pageEncoding="utf-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;测试页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; $&#123;msg&#125;&lt;/body&gt;&lt;/html&gt; 编写Controller1234567891011121314151617import org.springframework.ui.Model;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.servlet.ModelAndView;@RestController@RequestMapping("/index")public class MyController &#123; @GetMapping public ModelAndView index(Model model)&#123; model.addAttribute("msg","这是测试页面"); return new ModelAndView("index"); &#125;&#125; 启动项目，访问：localhost:8080/index 内嵌tomcat属性配置123456789#用户绘画session过期时间，以秒为单位server.servlet.session.timeout=36000m# 配置默认访问路径，默认为/server.servlet.context-path=/# 配置Tomcat编码,默认为UTF-8server.tomcat.uri-encoding=UTF-8# 配置最大线程数server.tomcat.max-threads=1000 配置外部tomcat容器部署war包Spring Boot项目需要部署在外部容器中的时候，Spring Boot导出的war包如果直接在Tomcat的部署会报错，如需运行需进行如下修改 1、启动类继承SpringBootServletInitializer 外部容器部署的话，就不能依赖于Application的main函数了，而是要以类似于web.xml文件配置的方式来启动Spring应用上下文，此时我们需要在启动类中继承SpringBootServletInitializer并实现configure方法： 12345678910111213141516171819202122import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.builder.SpringApplicationBuilder;import org.springframework.boot.web.servlet.support.SpringBootServletInitializer;@SpringBootApplicationpublic class SpringbootJspApplication extends SpringBootServletInitializer &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootJspApplication.class, args); &#125; /** * 部署到tomcat需要添加如下代码 * @param application * @return */ @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; return application.sources(SpringbootJspApplication.class); &#125;&#125; 2、修改pom.xml 添加依赖12345&lt;!--因配置外部TOMCAT 而配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/dependency&gt; 修改打包方式，把jar改成war 1234&lt;!--版本--&gt; &lt;version&gt;1&lt;/version&gt; &lt;!--打包方式--&gt; &lt;packaging&gt;war&lt;/packaging&gt; 如果想修改打包的名称，需在build节点中加入 123&lt;build&gt; &lt;finalName&gt;springBootJsp&lt;/finalName&gt;&lt;/bulid&gt; 添加外部tomcat并运行 启动项目，依旧能看到页面 项目源码github：https://github.com/dqjdda/SpringBoot_All 码云：https://gitee.com/hgpt/SpringBoot_All 开源后台管理系统：欢迎体验Aurora github: https://github.com/dqjdda/Aurora 码云： https://gitee.com/hgpt/Aurora]]></content>
      <categories>
        <category>Spring boot 循序渐进</category>
      </categories>
      <tags>
        <tag>Aurora 脚手架系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring boot 集成druid连接池]]></title>
    <url>%2Fblog%2F501.html</url>
    <content type="text"><![CDATA[前言Druid是一个关系型数据库连接池，是阿里巴巴的一个开源项目，地址：https://github.com/alibaba/druid。Druid不但提供连接池的功能，还提供监控功能，可以实时查看数据库连接池和SQL查询的工作情况。 配置Druid依赖12345678910111213141516171819202122232425&lt;!--web--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mysql--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- druid数据源驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;!--jpa--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; Druid数据源配置这里提供application.yml和application.properties两种配置 application.yml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263server: port: 8080#配置数据源spring: datasource: druid: # 数据库访问配置, 使用druid数据源 type: com.alibaba.druid.pool.DruidDataSource driverClassName: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/druid?useUnicode=true&amp;characterEncoding=utf8 username: root password: 123456 # 连接池配置 initial-size: 5 min-idle: 5 max-active: 20 # 连接等待超时时间 max-wait: 30000 # 配置检测可以关闭的空闲连接间隔时间 time-between-eviction-runs-millis: 60000 # 配置连接在池中的最小生存时间 min-evictable-idle-time-millis: 300000 validation-query: select '1' from dual test-while-idle: true test-on-borrow: false test-on-return: false # 打开PSCache，并且指定每个连接上PSCache的大小 pool-prepared-statements: true max-open-prepared-statements: 20 max-pool-prepared-statement-per-connection-size: 20 # 配置监控统计拦截的filters, 去掉后监控界面sql无法统计, 'wall'用于防火墙 filters: stat # Spring监控AOP切入点，如x.y.z.service.*,配置多个英文逗号分隔 aop-patterns: me.aurora.servie.* # WebStatFilter配置 web-stat-filter: enabled: true # 添加过滤规则 url-pattern: /* # 忽略过滤的格式 exclusions: '*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*,/plugins/*,/my/*' # StatViewServlet配置 stat-view-servlet: enabled: true # 访问路径为/druid/时，跳转到StatViewServlet url-pattern: /druid/* # 是否能够重置数据 reset-enable: false # 需要账号密码才能访问控制台 login-username: druid login-password: 123456 # IP白名单 # allow: 127.0.0.1 # IP黑名单（共同存在时，deny优先于allow） # deny: 192.168.1.218 # 配置StatFilter filter: stat: log-slow-sql: true application.properties1234567891011121314151617181920212223242526272829303132333435363738394041424344server.port=8080# 数据源配置spring.datasource.druid.driver-class-name=com.mysql.jdbc.Driverspring.datasource.druid.url=jdbc:mysql://localhost:3306/druid?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=falsespring.datasource.druid.username=rootspring.datasource.druid.password=123456# 初始化时建立物理连接的个数spring.datasource.druid.initial-size=5# 最大连接池数量spring.datasource.druid.max-active=30# 最小连接池数量spring.datasource.druid.min-idle=5# 获取连接时最大等待时间，单位毫秒spring.datasource.druid.max-wait=60000# 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒spring.datasource.druid.time-between-eviction-runs-millis=60000# 连接保持空闲而不被驱逐的最小时间spring.datasource.druid.min-evictable-idle-time-millis=300000# 用来检测连接是否有效的sql，要求是一个查询语句spring.datasource.druid.validation-query=SELECT 1 FROM DUAL# 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。spring.datasource.druid.test-while-idle=true# 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。spring.datasource.druid.test-on-borrow=false# 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。spring.datasource.druid.test-on-return=false# 是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。spring.datasource.druid.pool-prepared-statements=true# 要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。spring.datasource.druid.max-pool-prepared-statement-per-connection-size=50# 配置监控统计拦截的filters，去掉后监控界面sql无法统计spring.datasource.druid.filters=stat,wall# 通过connectProperties属性来打开mergeSql功能；慢SQL记录spring.datasource.druid.connection-properties=druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500# 合并多个DruidDataSource的监控数据spring.datasource.druid.use-global-data-source-stat=true# 需要账号密码才能访问控制台spring.datasource.druid.stat-view-servlet.login-username=adminspring.datasource.druid.stat-view-servlet.login-password=123456# 忽略过滤的格式spring.datasource.druid.web-stat-filter.exclusions=*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/* 其他配置可参考官方https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter 这时，启动项目，访问localhost:8080 关于Druid的更多说明，可查看官方wiki： 常见问题 项目源码github：https://github.com/dqjdda/SpringBoot_All 码云：https://gitee.com/hgpt/SpringBoot_All 开源后台管理系统：欢迎体验Aurora github: https://github.com/dqjdda/Aurora 码云： https://gitee.com/hgpt/Aurora]]></content>
      <categories>
        <category>Spring boot 循序渐进</category>
      </categories>
      <tags>
        <tag>Aurora 脚手架系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring boot 基础配置]]></title>
    <url>%2Fblog%2F500.html</url>
    <content type="text"><![CDATA[前言上一篇文章介绍了如何开启spring boot，这篇文章将介绍spring boot的一些基本配置，通过这篇文章，你将知道：spring boot全局配置、配置文件的优先级、如何读取自定义配置文件、如何通过命令行方式运行、如何定制Banner等 定制BannerSpring Boot项目在启动的时候会有一个默认的启动图案： 123456 . ____ _ __ _ _ /\\ / ___'_ __ _ _(_)_ __ __ _ \ \ \ \( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \ \\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/ 只需要在src/main/resources目录下新建banner.txt文件,把我们自己的图案复制进去，就能自定义这个图案，当然可以通过网站：http://patorjk.com/software/taag/ 一键生成，我们使用Aurora生成，效果如下 配置文件的优先级application.properties和application.yml文件可以放在以下四个位置： 外置，在相对于应用程序运行目录的/congfig子目录里。 外置，在应用程序运行的目录里 内置，在config包内 内置，在Classpath根目录 如果你在相同优先级位置同时有application.properties和application.yml，那么application.properties里的属性里面的属性就会覆盖application.yml 测试：在resources目录下分别新建application.properties和application.yml，指定端口启动 application.properties内容 1server.port=8081 application.yml内容 12server: port: 8080 启动服务，可以看到spring boot加载的是application.properties的内容 自定义属性的读取有时候项目需要用到自定义的属性，在application.properties中定义 12me.zhengjie.name=zhengjieme.zhengjie.pass=123456 使用@Value(value=”${属性名称}”)，将值绑定到相应属性上，并且在启动类中加入控制器，使其可以直接访问，如： 12345678910111213141516171819@RestController@SpringBootApplicationpublic class SpringbootDeployApplication &#123; @Value("$&#123;me.zhengjie.name&#125;") private String name; @Value("$&#123;me.zhengjie.pass&#125;") private String pass; @GetMapping("/") public String index()&#123; return "name:"+name+",pass:"+pass; &#125; public static void main(String[] args) &#123; SpringApplication.run(SpringbootDeployApplication.class, args); &#125;&#125; 启动项目，访问http://localhost:8081，页面显示如下： 在属性非常多的情况下，也可以定义一个和配置文件对应的Bean：通过注解@ConfigurationProperties(prefix=”me.zhengjie”)指明了属性的通用前缀，通用前缀加属性名和配置文件的属性名对应。12345678910@Component@ConfigurationProperties(prefix="me.zhengjie")public class MyProperties &#123; private String name; private String pass; // get,set略&#125; 在之前的启动类中，注入该Bean，即可获取属性值1234567@Autowired private MyProperties myProperties; @GetMapping("/test") public String index1()&#123; return "name:"+myProperties.getName()+",pass:"+myProperties.getPass(); &#125; 启动项目，访问http://localhost:8081/test，页面显示如下 属性间的引用在application.properties配置文件中，各个属性可以相互引用，如下：1234me.zhengjie.name=zhengjieme.zhengjie.pass=123456me.zhengjie.nameAndPass=$&#123;me.zhengjie.name&#125;--$&#123;me.zhengjie.pass&#125; 自定义配置文件在src/main/resources路径下新建一个application-test.properties配置文件1me.zhengjie.test=test 定义一个对应的Bean12345678910@Configuration@ConfigurationProperties(prefix="me.zhengjie")@PropertySource("classpath:application-test.properties")@Componentpublic class MyTestProperties &#123; private String test; // get,set略&#125; 注解@PropertySource(“classpath:application-test.properties”)指明了使用哪个配置文件 命令行方式运行通过命令行的方式运行spring boot程序12345java -jar xx.jar --使用默认的配置文件运行外部配置文件java -Dspring.config.location=E:\resources\xx.properties -jar xx.jar修改端口号java -jar xx.jar --server.port=8888 项目源码github：https://github.com/dqjdda/SpringBoot_All 码云：https://gitee.com/hgpt/SpringBoot_All 开源后台管理系统：欢迎体验Aurora github: https://github.com/dqjdda/Aurora 码云： https://gitee.com/hgpt/Aurora]]></content>
      <categories>
        <category>Spring boot 循序渐进</category>
      </categories>
      <tags>
        <tag>Aurora 脚手架系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开启 Spring boot]]></title>
    <url>%2Fblog%2F80.html</url>
    <content type="text"><![CDATA[追述历史在 Spring 早期的的1.x版本中，当时的JDK还不支持注解，因此只能只用 xml 。在JDK升级到JDK1.5后，它加入了注解的新特性，从此注解就被广泛的使用起来。有人支持肯定也会有人反对，于是 Spring 内部也分成了两派，一边是使用XML 的赞同派，一边是使用注解的赞同派。为了简化开发，在 Spring 2.x 之后的版本也引入了注解，不过只是少量的，如 @Component、@Service 等，但是功能还不强大，因此对于 Spring 的开发，大对数情况下都是xml为主，注解为辅。随着注解的功能增强，尤其是 Servlet3.0 规范的提出，Web 容器可以脱离web.xml的部署，使得 Web容器完全可以基于注解开发。对于 Spring3.x 和 Spring4.x 的版本注解功能越来越强大，对于 xml 的依赖越来越少，到了 4.x 的版本后甚至可以完全脱离 xml ，因此在 Spring 中使用注解开发占据了主流的地位。 Spring boot 与 Spring的关系Pivotal 团队在原有 Spring 的基础上主要通过注解的方式继续简化了 Spring 框架的开发，他们基于 Spring 框架开发了 Spring boot。 所以 Spring boot 并非是替代 Spring 框架，而是让 Spring 框架更加容易得到快速的使用。 Spring boot的优点学习Spring boot前，我们先谈下它的优点。官方文档是这样说的，Spring boot 的有点如下： 创建独立的 Spring 应用程序 嵌入额 Tomcat、Jetty 或者 Undertow，无需部署 War 文件 允许通过 Maven 或者 Gradle 来根据需要获取 starter 尽可能的自动配置 Spring 对 xml 没有要求配置 开启Spring boot先确定自己安装的JDK是1.8版本或者以上，这里使用 idea 创建1、选择New-&gt;Project，直接点击下一步2、修改Group的名称，这个名称可以根据自己的实际需求进行修改，点击Next3、选择 Web，勾选Web，点击Next4、项目命名与项目路径，点击完成 简单演示项目新建好了，我们找到spring boot的启动类，这里方便演示，不再新建控制器，直接在入口类中编写代码 123456789101112131415161718import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@SpringBootApplicationpublic class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125; @RequestMapping("/") String index() &#123; return "Hello spring boot"; &#125;&#125; 启动项目，点击启动按钮或者打包成jar再启动，方式如图打包后，在target目录，会生成一个可执行的jar文件，使用命令启动：1java -jar demo-0.0.1-SNAPSHOT.jar 启动后访问：localhost：8080]]></content>
      <categories>
        <category>Spring boot 循序渐进</category>
      </categories>
      <tags>
        <tag>Aurora 脚手架系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL:使用SQL语句删除所有索引]]></title>
    <url>%2Fblog%2F100.html</url>
    <content type="text"><![CDATA[前言要清空所有的索引，首先得先清空所有的外键关联，清空所有外键关联可以参考：https://www.zhengjie.me/blog/99.html 删除所有索引可利用ALTER TABLE或DROP INDEX语句来删除索引。这里使用ALTER TABLE，首先查询所有索引，然后拼接成删除语句，复制执行即可12345#拼接SELECT CONCAT('ALTER TABLE ',i.TABLE_NAME,' DROP INDEX ',i.INDEX_NAME,' ;') FROM INFORMATION_SCHEMA.STATISTICS i#过滤主键索引WHERE TABLE_SCHEMA = '库名' AND i.INDEX_NAME &lt;&gt; 'PRIMARY'; 查询结果如下： 语法查询索引123456789SELECT *FROM INFORMATION_SCHEMA.STATISTICSWHERE TABLE_SCHEMA = '库名';#或者使用查看表的索引(1)show index from tblname;(2)show keys from tblname; 创建索引执行CREATE TABLE语句可以创建索引，也可以单独用CREATE INDEX或ALTER TABLE来为表增加索引。 ALTER TABLEALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。123(1.)ALTER TABLE table_name ADD INDEX index_name (column_list)(2.)ALTER TABLE table_name ADD UNIQUE (column_list)(3.)ALTER TABLE table_name ADD PRIMARY KEY (column_list) 其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。索引名index_name可选，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。 CREATE INDEXCREATE INDEX可对表增加普通索引或UNIQUE索引。12(1)CREATE INDEX index_name ON table_name (column_list)(2)CREATE UNIQUE INDEX index_name ON table_name (column_list) table_name、index_name和column_list具有与ALTER TABLE语句中相同的含义，索引名不可选。另外，不能用CREATE INDEX语句创建PRIMARY KEY索引。 删除索引123(1)DROP INDEX index_name ON talbe_name(2)ALTER TABLE table_name DROP INDEX index_name(3)ALTER TABLE table_name DROP PRIMARY KEY 其中，前两条语句是等价的，删除掉table_name中的索引index_name。第3条语句只在删除PRIMARY KEY索引时使用，因为一个表只可能有一个PRIMARY KEY索引，因此不需要指定索引名。如果没有创建PRIMARY KEY索引，但表具有一个或多个UNIQUE索引，则MySQL将删除第一个UNIQUE索引。如果从表中删除了某列，则索引会受到影响。对于多列组合的索引，如果删除其中的某列，则该列也会从索引中删除。如果删除组成索引的所有列，则整个索引将被删除。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>mysql清空索引</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MYSQL:使用SQL语句清空所有外键关联]]></title>
    <url>%2Fblog%2F99.html</url>
    <content type="text"><![CDATA[解决办法执行下面SQL语句查询数据库中所有外键名称然后拼接生成删除语句，再执行 SQL语句入下：1234#拼接所有外键SELECT CONCAT('ALTER TABLE ',TABLE_SCHEMA,'.',TABLE_NAME,' DROP FOREIGN KEY ',CONSTRAINT_NAME,' ;') FROM information_schema.TABLE_CONSTRAINTS c WHERE c.TABLE_SCHEMA='库名' AND c.CONSTRAINT_TYPE='FOREIGN KEY'; 执行结果如下，复制拼接好的sql语句，执行即可 检查结果123SELECT CONSTRAINT_NAMEFROM information_schema.TABLE_CONSTRAINTS c WHERE c.TABLE_SCHEMA='aurora' AND c.CONSTRAINT_TYPE='FOREIGN KEY';]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>mysql清空外键约束</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Java8新特性】新的日期和时间API]]></title>
    <url>%2Fblog%2F2.html</url>
    <content type="text"><![CDATA[前言Java 8之前的库对日期和时间的支持并不理想，为了解决这个问题，Java 8引入了一套全新的时间日期API，位于java.time路径下。 LocalDateLocalDate类型包含了年月日信息，下面举些LocalDate的使用示例：12345678LocalDate date = LocalDate.of(2018, 8, 30); // 2018-08-30int year = date.getYear(); // 2018int month = date.getMonth().getValue(); // 8int day = date.getDayOfMonth(); // 30// 查看该月有多少天int days = date.lengthOfMonth(); // 31// 是否是闰年boolean isLeap = date.isLeapYear(); // false 可以使用LocalDate.now()获取当天的日期信息：12// 查看当天 年月日LocalDate today = LocalDate.now(); // 2018-08-30 除了调用LocalDate的getYear方法外，我们也可以使用ChronoField枚举类型来实现相同的功能：12345int year1 = date.get(ChronoField.YEAR); // 2018int month1 = date.get(ChronoField.MONTH_OF_YEAR); // 8int day1 = date.get(ChronoField.DAY_OF_MONTH); // 30// 当前日期属于该月第几周int weekOfMonth = date.get(ChronoField.ALIGNED_WEEK_OF_MONTH); // 4 ChronoField枚举类型包含了诸多的属性可供选择： 我们也可以修改LocalDate对象：1234567LocalDate date3 = LocalDate.of(2018, 8, 30); // 2018-08-30LocalDate date4 = date3.withDayOfMonth(30); // 2018-08-30LocalDate date5 = date3.with(ChronoField.DAY_OF_MONTH, 30); // 2018-08-30LocalDate date6 = date3.withYear(2019); // 2019-08-30LocalDate date7 = date3.plusDays(5); // 2018-09-04LocalDate date8 = date3.plus(5, ChronoUnit.DAYS); // 2018-09-04LocalDate date9 = date3.minusYears(10); // 2008-08-30 TemporalAdjusters类提供了许多静态方法来修改LocalDate对象。当我们需要获取下一个周天，下一个工作日，本月的最后一天等信息时，TemporalAdjusters类便可派上用场：1234import static java.time.temporal.TemporalAdjusters.*;LocalDate date10 = date3.with(nextOrSame(DayOfWeek.MONDAY)); // 2018-09-03LocalDate date11 = date3.with(lastDayOfMonth()); // 2018-09-31LocalDate date12 = date3.with(previous(DayOfWeek.SATURDAY)); // 2018-08-25 可参考9月的日历来理解上面的结果： 我们还可以对LocalDate进行格式化操作：12345String str1 = date.format(DateTimeFormatter.BASIC_ISO_DATE); // 20180930String str2 = date.format(DateTimeFormatter.ISO_LOCAL_DATE); // 2018-09-30DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy-MM-dd");String str5 = date.format(dtf); // 2018-09-30LocalDate date13 = LocalDate.parse(str5, dtf); // 2018-09-30 LocalDate和下面要介绍的LocalTimeLocalDateTime之间共享了许多类似的方法，上面介绍的LocalDate修改、格式化等方法通用适用于LocalTime和LocalDateTime。 LocalTimeLocalTime和LocalDate类似，区别在于LocalTime包含的是时分秒（毫秒）信息。举些LocalTime的例子：1234LocalTime time = LocalTime.of(20, 13, 54); // 17:18:54int hour = time.getHour(); // 17int minute = time.getMinute(); // 18int second = time.getSecond(); // 54 LocalDate和LocalTime都可以通过字符串来创建：12LocalDate date = LocalDate.parse("2018-09-30");LocalTime time = LocalTime.parse("17:18:54"); LocalDateTimeLocalDateTime是LocalDate和LocalTime的组合形式，包含了年月日时分秒信息。举些LocalDateTime的使用示例：12LocalDateTime ldt1 = LocalDateTime.of(2018, 9, 30, 17, 18, 54); // 2018-09-30T17:18:54LocalDateTime ldt2 = LocalDateTime.of(date, time); // 2018-09-30T17:18:54 LocalDateTime可以转换为LocalDate和LocalTime，转换后包含的信息减少了：12LocalDate date1 = ldt1.toLocalDate(); // 2018-09-30LocalTime time1 = ldt1.toLocalTime(); // 17:18:54 同样的，LocalDate和LocalTime也可以转换为LocalDateTime，只需要补上日期或者时间：123LocalDateTime ldt3 = date.atTime(time); // 2019-09-30T17:18:54LocalDateTime ldt4 = date.atTime(17, 18, 54); // 2019-09-30T17:18:54LocalDateTime ldt5 = time.atDate(date); // 2019-09-30T17:18:54 DurationDuration用于计算两个LocalTime或者LocalDateTime的时间差，例如：123LocalTime time2 = LocalTime.of(23, 59, 59);Duration duration = Duration.between(time1, time2);long seconds = duration.getSeconds(); // 13565 time1和time2之间相差了13565秒。 手动创建Duration对象：12Duration threeMinutes = Duration.ofMinutes(3);threeMinutes = Duration.of(3, ChronoUnit.MINUTES); // 创建了一个3分钟的Duration，两种创建方式等价 PeriodPeriod用于计算两个LocalDate之间的时长。举些例子：1234LocalDate date2 = LocalDate.of(2018, 10, 31);Period period = Period.between(date1, date2);int monthsBetween = period.getMonths(); // 1int daysBetween = period.getDays(); // 1 2018-09-30和2018-10-30之间月份相差1，天数相差1。 同样的，我们也可以手动创建Period对象：123Period tenDays = Period.ofDays(10);Period threeWeeks = Period.ofWeeks(3);Period twoYearsSixMonthsOneDay = Period.of(2, 6, 1); 其他一些常用的方法比较两个时间的先后1234LocalDate date15 = LocalDate.of(2018,9,31);date.isEqual(date15); // falsedate.isAfter(date15); // falsedate.isBefore(date15); // true MonthDay类的使用MonthDay只包含月日信息，可以用于存放类似于生日，结婚纪念日等信息。举个使用MonthDay的例子：123456LocalDate birthday = LocalDate.of(1999, 9, 9);MonthDay monthDay = MonthDay.of(birthday.getMonth(), birthday.getDayOfMonth());MonthDay currentMonthDay = MonthDay.from(LocalDate.now());if (currentMonthDay.equals(monthDay)) &#123; System.out.println("happy birthday!");&#125; 假如用户的生日是1999年9月9号，那么可以通过这种方法来判断今天是否是用户的生日，如果是的话便发送生日祝福。同样的也有YearMonth类。 原文：https://mrbird.cc/java8-new-time-date-api.html]]></content>
      <categories>
        <category>随笔</category>
        <category>Java8新特性</category>
      </categories>
      <tags>
        <tag>Java8新特性</tag>
        <tag>LocalDate</tag>
        <tag>LocalTime</tag>
        <tag>LocalDateTime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git同步提交代码到github和码云上]]></title>
    <url>%2Fblog%2F1.html</url>
    <content type="text"><![CDATA[前言github毕竟是国外的，有时候访问也不稳定，而且速度也比较慢，所有我在提交代码到github上的时候有时候会同步一份到码云，之前都是分为两步上传 先提交到github 将最新的代码复制一份到码云的文件夹，提交到码云 这种方式太笨了，如何在一个仓库里面同时提交到多个平台呢？ 实战分别克隆github和码云的项目到本地，修改一方的配置文件 项目案例 Github：https://github.com/dqjdda/Aurora 码云：https://gitee.com/hgpt/Aurora 配置修改.git文件夹内的config文件 将另一方 config文件内的[remote “origin”]，复制到该文件内，并且修改origin名称，名称可以自定义。 测试上传代码123456git add .git commit -m "update"#提交到githubgit push github master#提交到码云git push gitee master 更新代码1234#从github拉取更新git pull github#从码云拉取更新git pull gitee]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git提交代码到多个平台</tag>
        <tag>git入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 2.0.4 & Shiro1.4.0 后台脚手架]]></title>
    <url>%2Fblog%2F666.html</url>
    <content type="text"><![CDATA[AuroraAurora是一个简单高效的后台管理系统。项目基础框架采用全新的Java Web开发框架 —— Spring Boot2.0.4，消除了繁杂的XML配置，使得二次开发更为简单；数据访问层采用Spring boot Jpa，可快速高效对数据进行操作，消除了大量传统XML配置SQL的代码，分页使用Pageable；安全框架采用时下流行的Apache Shiro，可实现对按钮级别的权限控制；前端页面使用KidAdmin构建，并提供多套配色以供选择。 预览地址，临时域名，正式域名auaur.net，已在备案中http://xiswl.xyz SSM + shiro + redis 版移步https://gitee.com/quella01/Quella 功能模块系统功能模块组成如下所示：12345678910111213141516171819202122232425262728293031| _ _ _ ___ ____ ___ _| /.\ FJ L] F _ &quot;, F __ ] F _ &quot;, /.\| //_\\ J | | L J `-&apos;(| J |--| L J `-&apos;(| //_\\| / ___ \ | | | | | _ L | | | | | _ L / ___ \| / L___J \ F L__J J F |_\ L F L__J J F |_\ L / L___J \| J__L J__J\______/J__| \\__J\______/J__| \\__J__L J__L| |__L J__|J______F|__| J__|J______F|__| J__|__L J__||| :: Spring Boot :: (v2.0.4.RELEASE)|├─系统管理│ ├─用户管理│ ├─菜单管理│ ├─角色管理│ ├─权限管理│ ├─字典管理│ └─接口文档├─系统监控│ ├─Redis终端│ ├─SQL监控│ ├─在线用户│ └─系统日志│─第三方工具│ │-邮件工具│ │-支付宝支付│ │-七牛云储存│ │-SM.MS图床│ └─百度富文本编辑器└─任务调度 ├─定时任务 └─调度日志 技术选型后端 基础框架：Spring Boot 2.0.4.RELEASE 持久层框架：Spring boot Jpa 安全框架：Apache Shiro 1.4.0 摸板引擎：Thymeleaf 3.0.9.RELEASE 数据库连接池：阿里巴巴Druid 1.1.10 缓存框架：Redis 日志打印：logback sql语句内容打印: log4jdbc+logback IP地址池 ip2region 接口文档 swagger2 工具包：hutool-all 任务调度：quartz 其他：fastjson，aop，MapStruct等。 前端 基础框架：Layui（KidAdmin） JavaScript框架：jQuery 树形插件：ztree 树形选择框：treeselect 开发环境 语言：Java 8 IDE：IntelliJ IDEA 2018.2.2（Ultimate） 依赖管理：Maven 数据库：MySQL 5.5.59 版本管理：git 系统部分功能预览 前端模板使用kitadmin，前端框架使用layui 系统首页 用户管理 菜单管理，使用树形表格 日志管理 swagger文档 Redis终端 七牛云存储，支持同步数据到数据库 发送邮件功能 开发与部署码云地址：https://gitee.com/hgpt/Aurora GitHub 地址：https://github.com/dqjdda/Aurora 下载后以Maven项目的方式导入Eclipse或者IDEA。 1、项目需安装lombok插件 2、数据库文件目录 resources/sql/aurora.sql 3、项目需依赖redis，如果没安装reids请求将报错，安装步骤如下 安装RedisRedis的下载地址为https://github.com/MicrosoftArchive/redis/releases这里我们下载 Redis-x64-xxx.zip压缩包到C盘，解压后。打开一个CMD窗口，输入如下命令： 1234567891011121314151617181920C:\Users\Administrator&gt;cd c:\Redis-x64-3.2.100c:\Redis-x64-3.2.100&gt;redis-server.exe redis.windows.conf _._ _.-``__ &apos;&apos;-._ _.-`` `. `_. &apos;&apos;-._ Redis 3.2.100 (00000000/0) 64 bit .-`` .-```. ```\/ _.,_ &apos;&apos;-._ ( &apos; , .-` | `, ) Running in standalone mode |`-._`-...-` __...-.``-._|&apos;` _.-&apos;| Port: 6379 | `-._ `._ / _.-&apos; | PID: 6404 `-._ `-._ `-./ _.-&apos; _.-&apos; |`-._`-._ `-.__.-&apos; _.-&apos;_.-&apos;| | `-._`-._ _.-&apos;_.-&apos; | http://redis.io `-._ `-._`-.__.-&apos;_.-&apos; _.-&apos; |`-._`-._ `-.__.-&apos; _.-&apos;_.-&apos;| | `-._`-._ _.-&apos;_.-&apos; | `-._ `-._`-.__.-&apos;_.-&apos; _.-&apos; `-._ `-.__.-&apos; _.-&apos; `-._ _.-&apos; `-.__.-&apos;[6404] 25 Dec 09:47:58.890 # Server started, Redis version 3.2.100 然后打开另外一个CMD终端，输入：123C:\Users\Administrator&gt;cd c:\Redis-x64-3.2.100c:\Redis-x64-3.2.100&gt;redis-cli.exe127.0.0.1:6379&gt; 准备工作做完后，直接使用Spring Boot的入口类me.aurora.AuroraRun启动即可，访问地址[localhost] 部署时，首先使用使用mvn package将项目打包成jar或war，然后使用命令java -jar aurora-0.0.1-SNAPSHOT.war启动即可，当然也可以使用tomcat部署。 docker 中部署 项目提供了Dockerfile文件，可直接使用 更多帮助可参考链接https://www.zhengjie.me/categories/docker/。 反馈交流本人能有有限，项目如有不足之处，望指出 作者QQ：201507802 作者邮箱：zhengjie@tom.com 作者主页：https://www.zhengjie.me]]></content>
      <categories>
        <category>Spring boot</category>
      </categories>
      <tags>
        <tag>Aurora 脚手架系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jhipster 微服务与微服务相互通信]]></title>
    <url>%2Fblog%2F503.html</url>
    <content type="text"><![CDATA[现有两个微服务A和B，A负责管理用户信息，B负责角色管理。 A服务发送请求，绑定角色，B服务收到请求后，调用A服务查询用户是否存在，判断用户是否重复绑定，条件通过则绑定用户，最后反馈信息给A服务 A服务发送请求获取自己所有的权限，B服务收到请求后，调用A服务查询用户是否存在，存在则查询数据反馈信息给A服务 上面两个例子将用户和角色进行解耦，两者相互通信，那么微服务与微服务之间如何实现相互通信，这里将用一个简单的例子来说明。 B服务控制器中添加Rest方法，为A服务提供调用123456789@GetMapping(value = "/roles/getRoles/&#123;userID&#125;")@Timedpublic ResponseEntity getRolesByUserID(@PathVariable(value = "userID") Long userID)&#123; log.debug("REST request to get Roles by UserID : &#123;&#125;", userID); //这里演示不做验证，直接New一个 Role返回Name Role role = new Role(); role.setName("超级管理员"); return new ResponseEntity(role.getName(),HttpStatus.OK);&#125; A服务声明一个接口，接口中添加B服务的Rest方法@AuthorizedFeignClient(name = &quot;b&quot;)，指定与哪个微服务通信 12345678import cn.netbank.cloud.app.client.AuthorizedFeignClient;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;@AuthorizedFeignClient(name = "b")public interface UserClient &#123; @GetMapping(value = "/api/roles/getRoles/&#123;userID&#125;") String getRolesByUserID(@PathVariable(value = "userID") Long userID);&#125; A服务的控制器中注入UserClient12@Resourceprivate UserClient userClient; A服务控制器中编写Rest方法12345678@GetMapping(value = "/users/getRoles/&#123;userID&#125;")@Timedpublic ResponseEntity getRolesByUserID(@PathVariable(value ="userID") Long userID)&#123; log.debug("REST request to Get Roles : &#123;&#125;", userID); //调用接口中的方法 String roleName = userClient.getRolesByUserID(userID); return new ResponseEntity(roleName,HttpStatus.OK);&#125; 最后在swagger ui中调试]]></content>
      <categories>
        <category>JHipster</category>
      </categories>
      <tags>
        <tag>Jhipster微服务调用微服务</tag>
        <tag>微服务相互通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jhipster 如何彻底删除Entity]]></title>
    <url>%2Fblog%2F498.html</url>
    <content type="text"><![CDATA[Jhipster为我们提供了实体的相关命令，但是从图中可以看到并没有删除实体的操作 而且我们再次输入：yo jhipster:entity User 时，提供的选项中也没有清除这一选项 这也就意味着，我们将手动删除这个实体相关的所有文件（entity: domain, repository, rest, test, Angularjs controller &amp; services, HTML view, link in menu, HTML view），可能还将面临清理不彻底的问题。 一旦我们清理不彻底，下次更新这个微服务时，我们删除的这个实体又会自动生成 那么如何才能彻底删除？我在国外的一个网站上终于找到了一种方式，那就是脚本删除，命令如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#!/usr/bin/env bashecho;if [ -z &quot;$1&quot; ];then printf &quot;Required argument GROUP_ID你输入的 GROUP_ID 是 is not set. \nUsage: ./delete-entity.sh GROUP_ID ENTITY_NAME.\n&quot;; exit 1;else GROUP_ID=$1; echo &quot;你输入的包路径是 &apos;$1&apos;.&quot;;fiif [ -z &quot;$2&quot; ];then printf &quot;Required argument ENTITY_NAME is not set. \nUsage: ./delete-entity.sh GROUP_ID ENTITY_NAME .\n&quot;; exit 1;else ENTITY_NAME=$2; JAVA_ENTITY_NAME=`echo $&#123;ENTITY_NAME:0:1&#125; | tr &apos;[a-z]&apos; &apos;[A-Z]&apos;`$&#123;ENTITY_NAME:1&#125; echo &quot;你输入的实体名称是 &apos;$2&apos;.&quot; echo &quot;即将删除您的实体相关信息：&quot;; echo &quot;domain, repository, rest, test, controller &amp; services, DTO, Mapper ...&quot;;fiJAVA_ENTITY_NAME=`echo $&#123;ENTITY_NAME:0:1&#125; | tr &apos;[a-z]&apos; &apos;[A-Z]&apos;`$&#123;ENTITY_NAME:1&#125;UNDERSCORED_FOLDER_NAME=`echo $&#123;ENTITY_NAME&#125; | sed -r &apos;s/([a-z0-9])([A-Z])/\1-\L\2/g&apos;`QUESTION=$&apos;如果你想在将来重新生成实体，你可以选择保留实体自定义配置文件(.jhipster/&apos;$&#123;JAVA_ENTITY_NAME&#125;&apos;.json)\n你想删除实体定义文件吗？(yes or no)&apos;while true; do read -p &quot;$&#123;QUESTION&#125;&quot; yn case $yn in [Yy]* ) rm -rf ./.jhipster/$&#123;ENTITY_NAME&#125;.json; break;; [Nn]* ) break;; * ) echo &quot;Please answer yes or no.&quot;;; esacdoneecho;echo &quot;Starting to delete files...&quot;;echo;echo &quot;Starting to delete files...&quot;;rm -rf src/main/resources/config/liquibase/changelog/*_added_entity_$&#123;JAVA_ENTITY_NAME&#125;.xmlrm -rf src/main/java/$&#123;GROUP_ID&#125;domain/$&#123;JAVA_ENTITY_NAME&#125;.javarm -rf src/main/java/$&#123;GROUP_ID&#125;repository/$&#123;JAVA_ENTITY_NAME&#125;Repository.javarm -rf src/main/java/$&#123;GROUP_ID&#125;service/$&#123;JAVA_ENTITY_NAME&#125;Service.javarm -rf src/main/java/$&#123;GROUP_ID&#125;service/impl/$&#123;JAVA_ENTITY_NAME&#125;ServiceImpl.javarm -rf src/main/java/$&#123;GROUP_ID&#125;repository/search/$&#123;JAVA_ENTITY_NAME&#125;SearchRepository.javarm -rf src/main/java/$&#123;GROUP_ID&#125;web/rest/$&#123;JAVA_ENTITY_NAME&#125;Resource.javarm -rf src/main/java/$&#123;GROUP_ID&#125;web/rest/dto/$&#123;JAVA_ENTITY_NAME&#125;DTO.javarm -rf src/main/java/$&#123;GROUP_ID&#125;web/rest/mapper/$&#123;JAVA_ENTITY_NAME&#125;Mapper.javarm -rf target/generated-sources/$&#123;GROUP_ID&#125;web/rest/mapper/$&#123;JAVA_ENTITY_NAME&#125;MapperImpl.javarm -rf src/main/webapp/app/entities/$&#123;UNDERSCORED_FOLDER_NAME&#125;/*rm -rf src/test/java/$&#123;GROUP_ID&#125;web/rest/$&#123;JAVA_ENTITY_NAME&#125;ResourceIntTest.javarm -rf src/test/gatling/simulations/$&#123;JAVA_ENTITY_NAME&#125;GatlingTest.scalarm -rf src/test/javascript/spec/app/entities/$&#123;UNDERSCORED_FOLDER_NAME&#125;/*rm -rf src/test/javascript/spec/app/entities/$&#123;UNDERSCORED_FOLDER_NAME&#125;rm -rf src/main/webapp/i18n/en/$&#123;ENTITY_NAME&#125;.jsonrm -rf src/main/webapp/i18n/fr/$&#123;ENTITY_NAME&#125;.jsonrm -rf src/main/webapp/i18n/ru/$&#123;ENTITY_NAME&#125;.jsonrm -rf src/main/webapp/i18n/uz/$&#123;ENTITY_NAME&#125;.jsonecho &quot;Deleting entity &apos;$&#123;ENTITY_NAME&#125;&apos; is completed.&quot;;echo;echo &quot;-----------------------------------------------------&quot;;echo &quot;Do not forget to manually correct these files also: &quot;;echo &quot;-----------------------------------------------------&quot;;echo &quot; --&gt; src/main/webapp/index.html&quot;echo &quot; --&gt; src/main/webapp/scripts/compopnents/navbar.html&quot;echo &quot; --&gt; src/main/webapp/i18n/**/global.json&quot;echo &quot; --&gt; src/main/resources/config/liquibase/master.xml (if you use liquibase)&quot;echo &quot; --&gt; src/main/resources/config/mongeez/master.xml (if you use mongodb)&quot; 复制该代码，保存delete-entity.sh，文件后缀为.sh，我们将这个文件置于这个项目的根目录中，只需要执行：delete-entity.sh [package]/ [entityName]如：delete-entity.sh me/zhengjie/ User 注意：package在这里不能使用.，不然会找不到文件，需要使用/,最后也需要加上/ 弹出如下窗口，输入yes，即可彻底删除 注意有些东西是需要手动更新的，如:12345src/main/webapp/index.htmlsrc/main/webapp/scripts/compopnents/navbar.htmlsrc/main/webapp/i18n/**/global.jsonsrc/main/resources/config/liquibase/master.xml (if you use liquibase)src/main/resources/config/mongeez/master.xml (if you use mongodb) 重启项目，发现报错 进入目录，src/main/resources/config/liquibase/master.xml 删除文件中报错的行即可。]]></content>
      <categories>
        <category>JHipster</category>
      </categories>
      <tags>
        <tag>jhipster删除实体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jhipster创建实体，Gateway数据菜单为空]]></title>
    <url>%2Fblog%2F494.html</url>
    <content type="text"><![CDATA[在微服务创建entity后还需要在Gateway中同步一次，只有这样Gateway中才会生成相应的页面，不然访问他的数据菜单会是一个空的。切换到app文件夹，根据提示创建一个实体，可参考链接: JHipster 创建实体，并且增加关联关系 1234cd appyo jhipster:entity Role --table-name role......Overwrite src\main\resources\config\liquibase\master.xml? (ynaxdH) Y 创建完成后，打开网关服务，查看数据菜单，发现并没有我们添加的实体 这是因为我们只是在app中添加了Role，并没有将Role同步到gateway中 123456789cd gatewayyo jhipster:entity Role#是否从一个已经存在的微服生成Do you want to generate this entity from an existing microservice? Y#输入我们微服务的根路径（相对路径和绝对路径都可以）Enter the path to the microservice root directory: ../app#是否更新实体Do you want to update the entity? YOverwrite src\main\webapp\app\layouts\navbar\navbar.component.html? (ynaxdH) y 再次打开http://10.93.0.96:8080/#/，就能够查就能够对我们的实体进行操作了。]]></content>
      <categories>
        <category>JHipster</category>
      </categories>
      <tags>
        <tag>jhipster Gateway数据菜单为空</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Java8新特性】使用Optional取代null]]></title>
    <url>%2Fblog%2F492.html</url>
    <content type="text"><![CDATA[在Java中对一个空对象进行操作时，便会抛出最常见的异常NullPointerException。为了改善这个问题，Java 8中提供了一个java.util.Optional类型。Optional类的Javadoc描述如下：这是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。 类声明以下是一个 java.util.Optional 类的声明： 1public final class Optional&lt;T&gt; extends Object 类创建创建一个Optional对象有好几种方式： 创建一个空的Optional我们可以使用静态工厂方法Optional.empty，创建一个空的Optional对象： 1Optional&lt;Department&gt; department = Optional.empty(); 根据非空值创建Optional我们也可以使用静态工厂方法Optional.of来创建一个非空对象的Optional对象：1Optional&lt;Employee&gt; optEmployee = Optional.of(employee); 如果employee为空，这段代码会立即抛出一个NullPointerException 创建可以为null的Optional使用静态工厂方法Optional.ofNullable，我们可以创建一个允许null值的Optional对象：1Optional&lt;Employee&gt; optEmployee = Optional.ofNullable(employee); 如果employee为空，对其调用get方法将抛出NoSuchElementException。 Optional 实例我们可以通过以下实例来更好的了解 Optional 类的使用： 1234567891011121314151617181920212223import java.util.Optional;public class Java8Tester &#123; public static void main(String args[])&#123; Java8Tester java8Tester = new Java8Tester(); Integer value1 = null; Integer value2 = new Integer(10); // Optional.ofNullable - 允许传递为 null 参数 Optional&lt;Integer&gt; a = Optional.ofNullable(value1); // Optional.of - 如果传递的参数是 null，抛出异常 NullPointerException Optional&lt;Integer&gt; b = Optional.of(value2); System.out.println(java8Tester.sum(a,b)); &#125; public Integer sum(Optional&lt;Integer&gt; a, Optional&lt;Integer&gt; b)&#123; // Optional.isPresent - 判断值是否存在 System.out.println("第一个参数值存在: " + a.isPresent()); System.out.println("第二个参数值存在: " + b.isPresent()); // Optional.orElse - 如果值存在，返回它，否则返回默认值 Integer value1 = a.orElse(new Integer(0)); //Optional.get - 获取值，值需要存在 Integer value2 = b.get(); return value1 + value2; &#125;&#125; 执行以上代码，输出结果为： 12345$ javac Java8Tester.java$ java Java8Tester第一个参数值存在: false第二个参数值存在: true10]]></content>
      <categories>
        <category>随笔</category>
        <category>Java8新特性</category>
      </categories>
      <tags>
        <tag>Java8新特性</tag>
        <tag>Optional</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jhipster 创建微服务]]></title>
    <url>%2Fblog%2F478.html</url>
    <content type="text"><![CDATA[简介jHipster 集成了springcloud的注册中心（eureka server）和配置中心（config server），eureka server 能够将我们自己开发的微服务（Microservices）都纳入到它自身当中，config server 能够集中管理应用程序各个环境下的配置，默认使用git 仓库存储配置内容。 Microservices没有前端页面，前端页面由网关产生（gateway），权限控制可以通过UAA进行管理，并且要在JHipster Registry中注册、发现和管理。 JHipster Registry 是微服架构必不可少的。它把所有的组件连接在一起，使他们能够互相通信。 Microservices 它只有后台代码。它更注重的是在API上。一个微服结构可以有许多微服应用，每个包含几个相关的实体和业务规则。Gateway 它为所有微服务提供了HTTP路由和负载均衡，服务质量，安全和API文档。 UAA是一个使用OAuth2认证协议、为JHipster微服务提供用户账户和授权的服务。 微服务安装安装JHipster Registry由于 JHipster Registry 是一个标准的jhipster，所以我们只需要克隆下来运行它即可。没有必要打开idea或者修改它： 第一种方式123git clone https://github.com/jhipster/jhipster-registry#cd到jhipster-registry文件夹，运行mvnw 执行mvnw命令后，系统将自动编译运行。 第二种方式1234git clone https://github.com/jhipster/jhipster-registry.git# 编译启动mvn clean packagejava -jar target/jhipster-registry-*.war 打开http://localhost:8761/，并且登录，默认账户admin，密码admin。 Instances Registered是自动注册的服务，当我们创建服务后，将自动注册到这里 安装uaa部署完jHipster registry ，我们需要创建一个用于控制访问权限的项目。 123456789101112131415161718192021222324#创建文件夹存放项目mkdir uaa#切换到文件夹cd uaa#创建UAA服务yo jhipster#仅供参考? (1/14) Which *type* of application would you like to create? [BETA] JHipster UAA server (for microservice OAuth2 authentication)? (2/14) What is the base name of your application? uaa? (3/14) Would you like to install other generators from the JHipster Market Place? No? (3/14) As you are running in a microservice architecture, on which port would like your server to run? It should be unique to avoid port conflicts. 9999? (4/14) What is your default Java package name? cn.jhipter.uaa? (5/14) Which Service Discovery and Configuration solution would you like to use? JHipster Registry (using Eureka and Spring Cloud Config)? (6/14) Which *type* of database would you like to use? SQL (H2, MySQL, MariaDB, PostgreSQL, Oracle, MSSQL)? (7/14) Which *production* database would you like to use? MySQL? (8/14) Which *development* database would you like to use? MySQL? (9/14) Do you want to use Hibernate 2nd level cache? Yes, with HazelCast (distributed cache, for multiple nodes)? (10/14) Would you like to use Maven or Gradle for building the backend? Maven? (11/14) Which other technologies would you like to use? (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to inverse selection)? (12/14) Would you like to enable internationalization support? Yes#国际化支持，选择简体中文? Please choose the native language of the application? Chinese (Simplified)? Please choose additional languages to install (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to inverse selection)? (13/14) Which testing frameworks would you like to use? (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to inverse selection)Gatling 通过mvnw编译启动项目 创建Microservices Application操作同uaa 12345678910111213141516171819202122232425#创建文件夹存放项目mkdir app#切换到文件夹cd app#创建微服务yo jhipster#仅供参考? (1/14) Which *type* of application would you like to create? Microservice application? (2/14) What is the base name of your application? app? (3/14) Would you like to install other generators from the JHipster Market Place? No? (3/14) As you are running in a microservice architecture, on which port would like your server to run? It should be unique to avoid port conflicts. 8081? (4/14) What is your default Java package name? cn.jhipster.app? (5/14) Which *type* of authentication would you like to use? [BETA] Authentication with JHipster UAA server (the server must be generated separately)? (6/14) What is the folder path of your UAA application?. ../uaa? (7/14) Which Service Discovery and Configuration solution would you like to use? JHipster Registry (using Eureka and Spring Cloud Config)? (8/14) Which *type* of database would you like to use? SQL (H2, MySQL, MariaDB, PostgreSQL, Oracle)? (9/14) Which *production* database would you like to use? MySQL? (10/14) Which *development* database would you like to use? MySQL? (11/14) Do you want to use Hibernate 2nd level cache? Yes, with HazelCast (distributed cache, for multiple nodes)? (12/14) Would you like to use Maven or Gradle for building the backend? Maven? (13/14) Which other technologies would you like to use? (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to inverse selection)? (14/14) Would you like to enable internationalization support? Yes? Please choose the native language of the application? Chinese (Simplified)? Please choose additional languages to install (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to inverse selection)? (15/14) Which testing frameworks would you like to use? (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to inverse selection)Gatling 同样还需要修改数据库配置\src\main\resources\config\application-dev.yml，在application.yml中可以看到，系统已经自动帮我们注册了 启动项目（参考uaa） 创建网关(Gateway)创建一个网关，用来做为所有请求的入口 1234567891011121314151617181920212223242526#创建文件夹存放项目mkdir gateway#切换到文件夹cd gateway#创建微服务网关yo jhipster#仅供参考? (1/14) Which *type* of application would you like to create? Microservice gateway? (2/14) What is the base name of your application? gateway? (3/14) Would you like to install other generators from the JHipster Market Place? No? (3/14) As you are running in a microservice architecture, on which port would like your server to run? It should be unique to avoid port conflicts. 8080? (4/14) What is your default Java package name? cn.jhipster.gateway? (5/14) Which *type* of authentication would you like to use? [BETA] Authentication with JHipster UAA server (the server must be generated separately)? (6/14) What is the folder path of your UAA application?. ../uaa? (7/14) Which Service Discovery and Configuration solution would you like to use? JHipster Registry (using Eureka and Spring Cloud Config)? (8/14) Which *type* of database would you like to use? SQL (H2, MySQL, MariaDB, PostgreSQL, Oracle, MSSQL)? (9/14) Which *production* database would you like to use? MySQL? (10/14) Which *development* database would you like to use? MySQL? (11/14) Do you want to use Hibernate 2nd level cache? Yes, with HazelCast (distributed cache, for multiple nodes)? (12/14) Would you like to use Maven or Gradle for building the backend? Maven? (13/14) Which other technologies would you like to use? (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to inverse selection)? (14/14) Would you like to use the LibSass stylesheet preprocessor for your CSS? No? (15/14) Would you like to enable internationalization support? Yes? Please choose the native language of the application? Chinese (Simplified)? Please choose additional languages to install (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to inverse selection)? (16/14) Which testing frameworks would you like to use? (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to inverse selection)Gatling 同样需要修改数据库配置并启动项目 打开http://localhost:8761，就可以查看到我们创建的服务。 将它和网关服务进行对比，可以看出网关页面管理里面多了些菜单。 软件推荐： 由于创建都是敲命令实现的，而系统原生的cmd使用起来并不怎么友好，可以使用cmder这款软件进行操作。cmder是一个跨平台的命令行增强工具,可以集成windows batch, power shell, git, linux bash等多种命令行于一体,使用起来还是十分方便的 相关介绍： https://www.zhengjie.me/blog/465.html]]></content>
      <categories>
        <category>JHipster</category>
      </categories>
      <tags>
        <tag>JHipster入门</tag>
        <tag>jhipster微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决JHipster启动出现空白页的问题]]></title>
    <url>%2Fblog%2F443.html</url>
    <content type="text"><![CDATA[场景重现从git上拉取了一个JHipster项目，启动后，访问localhost:8080，出现的是空白的页面。 问题分析能启动，但是访问页面都是空白的，访问swagger-ui得不到样式，排除代码问题，初步确认为是前端部分没有构建。 问题解决1、切换到项目根目录 2、依次执行命令 123yarnyarn add node-sassyarn start yarn add node-sass 是安装依赖的node-sass包，在安装yarn时，如果node-sass没有安装成功，前端构建就会报错。 yarn start 会自动启动这个项目并打开浏览器页面。]]></content>
      <categories>
        <category>JHipster</category>
      </categories>
      <tags>
        <tag>Jhipster空白页问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[美化cmd，Windows神器推荐Cmder]]></title>
    <url>%2Fblog%2F465.html</url>
    <content type="text"><![CDATA[最近在使用JHipster，用的最多的就是在cmd中敲命令，但是Windows自带的doc窗口使用起来真的很不方便，而且也没有敲linux命令的感觉。百度了下，看到了这个工具，真的是相见恨晚 简介cmder是一个跨平台的命令行增强工具,可以集成windows batch, power shell, git, linux bash等多种命令行于一体,十分方便。 界面的差异在原生的doc窗口画风是这样的，而且查看文件夹不能使用ls，这对于一部分人来说真的很难受 在cmder中可以使用ls查看当前目录的所有文件夹，在cd文件时，会将相同名称的文件显示出来，当然他的强大不止这些 cmder安装打开官网http://cmder.net 会有两个版本可供选择，个人推荐安装Full版本 cmder快捷操作及部分说明 Cmder常用快捷键 可以利用Tab，自动路径补全(爽,赞！)； 可以利用Ctrl+T建立新页签； 利用Ctrl+W关闭页签; 还可以透过Ctrl+Tab切换页签; Alt+F4：关闭所有页签 Alt+Shift+1：开启cmd.exe Alt+Shift+2：开启powershell.exe Alt+Shift+3：开启powershell.exe (系统管理员权限) Ctrl+1：快速切换到第1个页签 Ctrl+n：快速切换到第n个页签( n值无上限) Alt + enter： 切换到全屏状态； Ctr+r 历史命令搜索; End, Home, Ctrl : Traversing text with as usual on Windows 可在视窗内搜寻画面上出现过的任意关键字。 新增页签按钮，可透过滑鼠新增页签。 切换页签按钮，可透过滑鼠切换页签。 锁定视窗，让视窗无法再输入。 切换视窗是否提供卷轴功能，启动时可查询之前显示过的内容。 按下滑鼠左键可开启系统选单，滑鼠右键可开启工具选项视窗。 Win+Alt+P ：开启工具选项视窗 其他功能 它可以使用简单的复制（Ctrl+C）粘贴（Ctrl+V） 它可以执行一些常见但指令超长又难以记忆的语法;比如 ls cls等等，在控制台输入alias可以查看 相关问题安装mini版本后出现乱码文字重叠解决方法]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>cmd</tag>
        <tag>cmder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JHipster 创建实体，并且增加关联关系]]></title>
    <url>%2Fblog%2F438.html</url>
    <content type="text"><![CDATA[当我们创建完应用时，可能想要创建一些实体类。例如我们想要创建一个User和Role实体类。对于每个实体，我们需要 一个数据库表 一个Liquibase变更set 一个JPA实体 一个Spring data jpa repository 一个带有基础增删改查的rest controller 一个angular路由、组件以及服务 一个HTML视图 集成测试 性能测试 如果我们有多个实体，你可能还想创建他们之间的关系，比如这个例子，你需要： 一个数据库外键 指定Javascript和HTML代码管理此关系 实体sub-generator(子生成器)，将会为每个实体创建所有需要的文件并且提供增删改查后端，sub-generator通过jhipster entity &lt;entityName&gt; --[options]运行。 注意：在Windows中，需要使用如下代码运行： 1yo jhipster:entity User --table-name user 它支持的选项有： --table-name &lt;table_name&gt; 通过JHipster会生成一个表，他的名称基于你的实体名称，如果你想要修改为不同的名称使用此选项 --angular-suffix &lt;suffix&gt; 如果你想所有的都带有自定义的后缀，可使用此选项 --regenerate 将会不做任何询问生成已存在的实体 --skip-server 不会服务端代码 --skip-client不会生成客户端代码 --db 跳过服务端代码生成时指定数据库 实体字段对于每个实体，你可以添加很多字段。你需要输入字段名称和类型，JHipster将会生成你所需的代码和配置。这些字段名称不能包含关键字 字段类型JHipster支持很多字段类型，这些支持依赖于你的后台数据库，所有我们使用Java类型去描述他们：一个Java String在Oracle和Cassandra中不同，这是Jhipster生成健壮和正确的数据库代码的一种方式。 String 它的默认长度取决于后端，如果你使用JPA默认长度255，你可以通过检验规则来修改它 Integer Long Float Double BigDecimal LocalDate 用于在Java中正确的管理日期 Instant 用于时间戳 ZoneDateTime 给定时区的本地时间 Enumeration 枚举对象，当选择此类型时，子生成器将会询问你对应的枚举值并创建enum类 Blob 用于存储二进制数据，当被选中时，子生成器会询问你存储的数据类型，是图片对象还是CLOB 尝试创建1234567891011121314151617181920212223242526272829创建一个Role的实体yo jhipster:entity Role --table-name rol要为实体添加字段吗？Do you want to add a field to your entity? (Y/n) y字段名称是什么？ What is the name of your field? name选择字段类型What is the type of your field? String为字段添加一些验证Do you want to add validation rules to your field? (y/N) y1、唯一约束2、最小长度3、最大长度4、正则表达是否继续添加字段Do you want to add a field to your entity? (Y/n) n是否关联实体Do you want to add a relationship to another entity? No生成DTO（DOT详解） Do you want to use a Data Transfer Object (DTO)? [BETA] Yes, generate a DTO with MapStruct生成ServiceDo you want to use separate service class for your business logic?Yes, generate a separate service interface and implementation添加分页Do you want pagination on your entity? Yes, with a simple pager不分页简单分页，基于bootstrap pager完成分页系统，基于Bootstrap pagination component滚动分页，基于infinite scroll directive 添加关联关系在上面的代码中就可以直接添加关联关系，这里我们演示修改实体，并且添加关联关系。 1234567891011121314151617181920212223242526再次输入yo jhipster:entity Role --table-name role你想更新实体吗？这将替换此实体的现有文件，所有自定义代码都将被覆盖Do you want to update the entity? This will replace the existing files for this entity, all your custom code will be overwritten (Use arrow keys)Yes, re generate the entity（是的，重新生成实体）Yes, add more fields and relationships（为实体添加新的字段）Yes, remove fields and relationships（是的，删除字段和关系）添加新的字段？Do you want to add a field to your entity? (Y/n) n是否关联其他实体Do you want to add a relationship to another entity? (Y/n) y实体的名称是什么？What is the name of the other entity? User关联关系的名称是什么？What is the name of the relationship? user选择关系类型What is the type of the relationship? (Use arrow keys) many-to-one many-to-one many-to-many one-to-one展示他们的关系时，使用User的哪个字段When you display this relationship with Angular, which field from &apos;User&apos; do you want to use? (id) username是否要为此关系添加任何验证规则？Do you want to add any validation rules to this relationship? (y/N) n是否关联其他实体Do you want to add a relationship to another entity? (Y/n) n 通过上面的命令，我们新增了Role，并且关联了User，并且为我们提供了后端的增删改查。]]></content>
      <categories>
        <category>JHipster</category>
      </categories>
      <tags>
        <tag>JHipster入门</tag>
        <tag>JHipster创建实体详细教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在windows中安装JHipster并创建应用]]></title>
    <url>%2Fblog%2F433.html</url>
    <content type="text"><![CDATA[jhipster框架是目前比较流行的一个架构，它为java服务器端开发提供了一整套的解决方案，它能够开发和部署spring boot和anjular web 以及基于spring的微服务应用。在使用jhipster之前，需要先安装nodejs、yeoman和Yeoman，这里提供了两种安装方式： 传统安装方法安装Nodejs LTS是正式版，Current是测试版，一般开发常用的就是LTS正式版，下载完成后，一直next安装即可，不需要设置环境变量，打开控制台，输入node -v出现版本号，即代表安装成功。 安装成功后建议设置npm镜像加速 1234npm config set registry https://registry.npm.taobao.orgnpm config set disturl https://npm.taobao.org/dist --global配置后可通过下面方式来验证是否成功npm config get registry 安装Yarn1npm install -g yarn react-native-cli 输入后会自动！安装完yarn后同理也要设置镜像源： 12yarn config set registry https://registry.npm.taobao.org --globalyarn config set disturl https://npm.taobao.org/dist --global 安装完yarn之后就可以用yarn代替npm了 安装 Yeoman（需要全局安装）1npm install -g yo 安装JHipster1yarn global add generator-jhipster 第二种方式通过官网给我们的一种安装方式（包管理器安装) 安装ChocolateyChocolatey是一个Windows上的包管理器，类似于linux上的yum和 apt-get。 安装步骤，点击这里，官网上提供两种方式，一种是在CMD中，一种是在PowerShell中。 这里我们使用CMD中的安装： @”%SystemRoot%\System32\WindowsPowerShell\v1.0\powershell.exe” -NoProfile -ExecutionPolicy Bypass -Command “iex ((New-Object System.Net.WebClient).DownloadString(‘https://chocolatey.org/install.ps1&#39;))&quot; &amp;&amp; SET “PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin” 打开CMD敲入命令，敲回车，就会自动安装，并且自动配置环境变量。 安装JHipster1choco install jhipster 回车以后，他只会提示Do you want to run the script? 这种提示，我们怎么知道他要下载什么，终于他成功的下载了所有的组件，包括我们有的（Node, Yarn, Yeoman, JDK 和 Git），如果我们电脑上有JDK 和 Git，或者不喜欢这种安装方式的可以选择第一种方式。 安装成功后测试安装成功后，我们尝试生成一个应用，输入： 1yo jhipster 创建应用时的问题你选择的问题答案不同可能会影响到接下来的问题显示 Q1. Which type of application would you like to create? Monolithic application: 单体应用 Microservice application: 微服务架构的service Microservice gateway: 微服务网关，为微服务请求进行路由和安全 JHipster UAA server: 基于OAuth2的安全认证微服务，后文详细解释 Q2. What is the base name of your application?你期望的应用的名称 Q3. What is your default Java package name?应用使用的默认包名，使用Yeoman的时候此值会被存储，当下次使用的时候此值会成为默认值，可覆写此值 Q4. Do you want to use the JHipster Registry to configure, monitor and scale your application?JHipster Registry是一个开源的工具，用于管理你正在运行的应用（微服务注册中心和统一配置中心），只有在微服务架构时才会使用 Q5. Which type of authentication would you like to use?所有可能的答案： JWT authentication: 使用JSON Web Token HTTP Session Authentication：经典的基于session认证的机制 OAuth 2.0 / OIDC Authentication: 使用OpenID连接服务，类似于Keycloak或者Okta Authentication with JHipster UAA server: 此种方式必须提前生成JHipster UAA Server (Q1的选项)，它是基于OAuth2的验证服务 Q6. Which type of database would you like to use?你可以选择的选项： No database，仅使用微服务架构时可用 An SQL database: 使用关系型数据库，将会采用Spring data jpa MongoDB Cassandra Couchbase Q7. Which production database would you like to use?选择你线上环境使用的数据库，此选项决定src/main/resources/config/application-prod.yml的配置 Q8. Which development database would you like to use?此选项决定你src/main/resources/config/application-dev.ymlprofile的数据库配置项，你可以选择： H2,running in-memory,数据存储在内存中，服务停掉数据消失 H2,with its data stored on disk,数据存储在硬盘，当前只是BETA测试且不能在Windows机器上工作 可以和Q7的选项一致 Q9. Do you want to use the Spring cache abstraction?由于Spring对于Cache的允许用户使用不同的cache实现，你可以使用chcache(本地缓存)，Hazelcast(分布式缓存)或者Infinispan（另一种分布式缓存）,此选项可以提升你的应用的性能 Q10. Do you want to use Hibernate 2nd level cache?此选项仅当你选择SQL数据库并且在Q9选择了一个缓存实现。Hibernate使用二级缓存可以更好的提升它的性能 Q11. Would you like to use Maven or Gradle?构建此项目时将要使用的工具，Maven或者Gradle Q12. Which other technologies would you like to use?多选，你可以为你的应用添加多种技术，如： Social login，社交登录功能 API first development using swagger-codegen：通过成swagger-codegen而使你的应用采用API优先的开发模式 Search engine using ElasticSearch: 对于ES的支持(Spring Data Elasticsearch) Clustered HTTP sessions using Hazelcast,默认情况下,JHipster只是用Http Session来存储Spring Security的身份验证和授权信息。如果你在集群中运行，使用HTTP Session将会导致一些数据一致的问题，如果你想在集群中复制session，请选择此项 Q13. WebSockets using Spring Websocket启用Websockets支持，将使用Spring WebSocket,JHipster提供了简单的例子展示如和高效的使用 Q14. Asynchronous messages using Apache Kafka是否使用Kafka来发布和订阅消息 Q15. Which Framework would you like to use for the client?选择使用那种客户端技术： Angular version 4+ AngularJS version 1.x Q16. Would you like to use the LibSass stylesheet preprocessor for your CSS?Node-sass对于设计CSS是一个优秀的解决方案，便于高效使用，你需要运行一个Gulp服务，jhipster会自动配置 Q17. Would you like to enable internationalization support?JHipster对于国际支持非常友好，你可以在客户端和服务端使用。但一般对于国际化要求不多的场景，可以不选择。 Q18. Which testing frameworks would you like to use?默认Jhipster提供了Java单元/集成测试（spring`s Junit）和JavaScript单元测试（Karma.js），你也可以选择： Performance tests using Gatling，性能测试 Gatling Behaviour tests using Cucumber,行为测试 Cucumber Angular integration tests with Protractor, angular集成测试Protractor Q19. Would you like to install other generators from the JHipster Marketplace?是否需要去JHipster商城安装第三方插件模块]]></content>
      <categories>
        <category>JHipster</category>
      </categories>
      <tags>
        <tag>JHipster安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker? 为什么要使用Docker？]]></title>
    <url>%2Fblog%2F430.html</url>
    <content type="text"><![CDATA[Docker 是一个开源的容器引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者和系统管理员在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括 VMs（虚拟机）、bare metal、OpenStack 集群、云端、数据中心和其他的基础应用平台。容器是完全使用沙箱机制，相互之间不会有任何接口。 为啥要用Docker？为啥要用Docker?这要从目前软件行业的痛点来讲起 软件更新发布及部署低效，过程繁琐且需要人工介入 环境一致性难以保证 不同环境之间迁移成本太高 有了Docker可以很大程度解决上面的问题。 首先，Docker的使用简单至极，从开发的角度来看就是三步走：构建，运输，运行。其中关键步骤就是构建环节，即打包镜像文件。但是从测试和运维的角度来看，那就只有两步：复制，运行。有了这个镜像，那么想复制到哪运行都可以，完全和平台无关了。同时Docker这种容器技术隔离出了独立的运行空间，不会和其他应用争用系统资源了以及还不需要考虑应用之间相互影响，想想就开心。 其次，因为在构建镜像的时候就处理完了服务程序对于系统的所有依赖，所以在你使用的时候，你可以忽略掉原本程序的依赖以及开发语言。对测试和运维而言，更多专注于自己的业务内容上。 最后，Docker于开发者而言提供了一种开发环境的管理办法，与测试人员而言保证了环境的同步，于运维人员提供了可移植的标准化部署流程。 Docker 能干啥 构建容易分发简单 隔离应用解除依赖 快速部署测完就销 Docker的应用场景在哪？？本地依赖(Local Dependency)你需要在本地系统快速尝试 Magento，或者为一个项目使用 MySQL？还是希望尝试大部分开源项目？那就使用 Docker 吧，它将帮你节省大量时间。Docker 能提升开发者的开发效率，让我们快速搭建开发环境。 开发环境的机器通常内存比较小，此前使用虚拟的时候，经常需要为开发环境的机器加内存，而通过 Docker 可以轻易的让几十个服务在 Docker 中跑起来。 搭建环境(Build Environment)如果你希望构建源码，但发现没有准备好合适的环境。 那么使用 Docker是一个值得考虑的方案。毕竟如果使用传统的方法一个一个地安装软件，一大堆软件安装下来确实十分费时间，使用容器技术省时省力，何乐而不为？它能让你将运行环境和配置放在代码中然后部署，同一个 Docker 的配置可以在不同的环境中使用，这样就降低了硬件要求和应用环境之间耦合度。这里有一个值得一看的例子： docker golang builder。 微服务(Microservices)你在使用微服务吗？微服务架构将一个整体式的应用拆分成松耦合的单个服务。 那不妨考虑一下 Docker，你可以将每个服务打包为一个docker镜像并使用docker-compose 来模拟生产环境(checkout docker networks)。最开始实践的时候可能会比较费时费力，但长远地来看，最终将产生巨大的生产力。 自动测试(Automated testing)试想这样一个问题，如何编写自动化的集成测试用例，这些测试用例无需花很长时间来开始运行，使用者也可轻松管理。这里不是指在 Docker 中运行测试用例，而是将测试用例与镜像紧密运行在一起。当你针对一个 docker 镜像编写测试用例时会有一个很大的优势。下面简单介绍一下我的测试流程：运行两个 docker 镜像(app + db)，在 MySQL 启动时加载数据，并在 app docker 上使用 API。可查看此脚本以获取快速的示例。 部署过程(Deployment process)你可以使用 docker 镜像进行自我部署。许多主流的主机提供商都支持托管 docker，如果你拥有一个具有 shell 访问权限的专用节点/vm，那么事情将变得更容易。只需要设置好docker，并在你想要的端口上运行你的镜像即可。 持续部署(Continuous Deployment)都说 Docker 天生适合持续集成/持续部署，在部署中使用Docker，持续部署将变得非常简单，并会在进入新的镜像后重新开始。关于这个部分的自动化工作，现在已经有许多方案以供选择，Kubernetes就是一个耳熟能详的名字。Kubernetes是容器集群管理系统，是一个开源的平台，可以实现容器集群的自动化部署、自动扩缩容、维护等功能。 多租户环境(Multi-tenancy)Docker 有意思的一个使用场景是在多租户的应用中，它可以避免关键应用的重写。如果你将应用程序服务公开给多个租户（租户指一组用户，例如组织），使用单租户方案设计的应用程序如果用上了 sub-domain + docker 可以快速获得提供多租户的服务。 关于这个场景的一个例子是为物联网的应用开发一个快速、易用的多租户环境。这种多租户的基本代码非常复杂，很难处理，重新规划这样一个应用不但消耗时间，也浪费金钱。使用Docker，可以为每一个租户的应用层的多个实例创建隔离的环境，这不仅简单而且成本低廉，当然这一切得益于 Docker 环境的启动速度和其高效的 diff 命令。 来自一台机器的多个 APP(Multiple apps from one machine)这与上面提到的微服务有些联系，但即使你没有使用微服务，只是提供服务，Docker仍可以很好地管理单个机器上的所有服务。你应该使用文件夹挂载来为每个基于数据的 docker 镜像保留数据。 扩容 QPS(Scaling QPS)Docker 通过创建另一个容器来帮助你轻松地进行水平扩展。如果遇到巨大的高峰流量，Docker可以帮助你解决问题 —— 只需添加更多的机器并增加负载均衡器背后运行的容器数量。 原文：http://www.techug.com/post/docker-for-10-things-adaca4cca7f8.html]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker使用范围</tag>
        <tag>docker入门</tag>
        <tag>为什么使用docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java开发-必学的Linux命令整合]]></title>
    <url>%2Fblog%2F429.html</url>
    <content type="text"><![CDATA[作为一个Java开发人员，有些常用的Linux命令必须掌握。即使平时开发过程中不使用Linux（Unix）或者mac系统，也需要熟练掌握Linux命令。因为很多服务器上都是Linux系统。所以，要和服务器机器交互，就要通过shell命令。 必会Linux命令清单查找文件find / -name filename.txt根据名称查找/目录下的filename.txt文件。 find . -name &quot;*.xml&quot;递归查找所有的xml文件 find . -name &quot;*&quot; |xargs grep &quot;hello&quot;递归查找所有文件内容中包含hello world的xml文件 grep -H &#39;spring&#39; *.xml查找所以有的包含spring的xml文件 find ./ -size 0 | xargs rm -f &amp;删除文件大小为零的文件 ls -l | grep &#39;.jar&#39;查找当前目录中的所有jar文件 grep &#39;test&#39; d*显示所有以d开头的文件中包含test的行。 grep &#39;test&#39; aa bb cc显示在aa，bb，cc文件中匹配test的行。 grep &#39;[a-z]\{5\}&#39; aa显示所有包含每个字符串至少有5个连续小写字符的字符串的行。 查看一个程序是否运行ps –ef|grep tomcat查看所有有关tomcat的进程 ps -ef|grep --color java高亮要查询的关键字 终止进程kill -9 19979终止线程号位19979的进程 查看文件，包含隐藏文件ls -al当前工作目录pwd复制文件cp source dest复制文件 cp -r sourceFolder targetFolder递归复制整个文件夹 scp sourecFile name@ip:addr远程拷贝 创建目录mkdir newfolder 删除目录rmdir deleteEmptyFolder删除空目录rm -rf deleteFile递归删除目录中所有内容 移动文件mv /temp/movefile /targetFolder 重命名mv oldNameFile newNameFile 切换用户su -username 修改文件权限chmod 777 file.javafile.java的权限-rwxrwxrwx，r表示读、w表示写、x表示可执行 压缩文件tar -czf test.tar.gz /test1 /test2 列出压缩文件列表tar -tzf test.tar.gz 解压文件tar -xvzf test.tar.gz 查看文件前10行head -n 10 example.txt 查看文件后10行tail -n 10 example.txt 查看日志最近更新tail -f exmaple.log这个命令会自动显示新增内容，屏幕只显示10行内容的（可设置）。 使用超级管理员身份执行命令sudo rm a.txt使用管理员身份删除文件 查看端口占用情况netstat -tln | grep 8080查看端口8080的使用情况 查看端口属于哪个进程lsof -i :8080 查看进程ps aux|grep java查看java进程 ps aux查看所有进程 以树状格式列出目录tree a PS：Mac下使用tree命令 文件下载wget http://file.tgz PS ：Mac下安装wget命令 curl http://file.tgz 网络检测ping www.just-ping.com 远程登录ssh userName@ip 打印信息echo $JAVA_HOME打印java home环境变量的值]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>java学习linux命令</tag>
        <tag>Linux命令</tag>
        <tag>linux学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[掌握这10条规范，轻松搞定Git！]]></title>
    <url>%2Fblog%2F428.html</url>
    <content type="text"><![CDATA[一、创建与合并分支从master分支创建dev分支并切换到dev分支： git checkout master git checkout -b dev 其中，git checkout -b dev 等价于： git branch dev git checkout dev 查看本地当前的分支分支前面带“*”表示当前分支，剩下的分支表示本地有的分支： git branch 查看远程全部的分支白色的表示本地有的，红色的表示本地没有，仅在远程存在： git branch -a 修改代码、提交代码（当前的操作是在dev分支上进行） git add a.html git commit -m “提交文件a.html” 分支合并(将dev合并到master) git checkout master git merge dev 合并完成后，删除dev分支.(删除dev分支时，注意我们当前所在的分支不能是dev分支) git branch -d dev 删除后，查看分支(此时看不到dev分支了) git branch 总结 ：工作中经常从master创建新的分支，具体操作如下： git checkout master git checkout -b issues1234 git push origin issues1234 git add . git commit -m “***” git push origin issues1234 注意：将本地分支branch1推到远端的branch2操作步骤： git push origin branch1:branch2 删除分支 git branch -D issues1234 //本地强制删除分支issues1234 git push origin :issues1234 //推到远程 二、 解决冲突发生冲突的文件 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD Creating a new branch is quick &amp; simple. ======= Creating a new branch is quick AND simple. feature1 其中，git使用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记文件中自己和别人产生冲突的部分。 在&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======之间为自己的代码； =======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;之间为别人的代码。 如果保留自己的代码，将别人的代码删掉即可。 2、冲突解决后提交 git status git add *** git commit -m “fix conflict” git push origin 分支名 三、Bug分支储藏更改:将当前更改的代码储藏起来，等以后恢复使用 git stash 查看储藏的代码 git stash list 注： git stash list //查看全部的stash列表。 3、恢复储藏的代码 git stash pop //恢复的同时把stash内容删掉 或者 git stash apply stash，但是stash内容并不删除 git stash drop 面操作的基础上，以此来删除stash 将stash空间清空 git stash clear git stash pop 和 git stash apply 区别 原来git stash pop stash@{id}命令会在执行后将对应的stash id 从stash list里删除，而 git stash apply stash@{id} 命令则会继续保存stash id。 四、版本回退回退至上一个版本 git reset –hard HEAD 回退至指定版本 git reset –hard 版本号 查看以往版本号(本地的commit) git reflog 查看各版本号及信息所有的commit：本地commit + 其他同事的commit git log 撤销修改撤销修改 git checkout – a.html 分两种情况分析： 还没有执行 git add 操作，执行上面的操作后，会恢复到和版本库中一模一样的版本状态。 执行了git add ，还没执行 git commit ,再执行上面的操作后，会恢复到git add 结束后的状态 注：一旦执行了git commit -m “*”，就不能再使用上面的命令回退。 六、对于已经push的版本，进行回退第一步： git reset –hard 版本号 //本地回退到指定的版本 第二步： git push -f origin dev //将远程的也回退到指定版本 七、本地同步远程删除的分支 git fetch origin -p 用来清除已经没有远程信息的分支，这样git branch -a 就不会拉取远程已经删除的分支了 八、删除掉没有与远程分支对应的本地分支从gitlab上看不到的分支在本地可以通过git branch -a 查到，删掉没有与远程分支对应的本地分支： git fetch -p 九、查看远程库的一些信息，及与本地分支的信息 git remote show origin 十、git stash临时保存本地操作1、使用git stash就可以将你当前未提交到本地（和服务器）的代码推入到Git的栈中，这时候你的工作区间和上一次提交的内容是完全一样的。 2、再切换到别的分支改紧急bug。 3、改完后，切到刚才的分支，使用git stash apply将以前一半的工作应用回来。 也许有的人会说，那我可不可以多次将未提交的代码压入到栈中？答案是可以的。当你多次使用git stash命令后，你的栈里将充满了未提交的代码，这时候你会对将哪个版本应用回来有些困惑，git stash list命令可以将当前的Git栈信息打印出来，你只需要将找到对应的版本号，例如使用git stash apply stash@{1}就可以将你指定版本号为stash@{1}的工作取出来，当你将所有的栈都应用回来的时候，可以使用git stash clear来将栈清空。 在这里顺便提下git format-patch-n, n是具体某个数字， 例如git format-patch-1这时便会根据log生成一个对应的补丁，如果git format-patch-2那么便会生成2个补丁，当然前提是你的log上有至少有两个记录。 作者：Miss_Ye 来自：https://segmentfault.com/a/1190000014461898]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git入门</tag>
        <tag>Git</tag>
        <tag>git stash临时保存本地操作</tag>
        <tag>git合并与删除分支</tag>
        <tag>git恢复stash内容</tag>
        <tag>git撤销修改</tag>
        <tag>git版本回退</tag>
        <tag>git解决冲突</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring boot整合SwaggerUI构建API文档]]></title>
    <url>%2Fblog%2F383.html</url>
    <content type="text"><![CDATA[SwaggerUI可以说是一个非常好用的API文档工具，它可以称为前后端开发人员的纽带，具体实现三步即可。 导入依赖包我这里使用gradle构建的项目，maven项目自行转换下 123//Swagger2依赖compile('io.springfox:springfox-swagger2:2.8.0')compile('io.springfox:springfox-swagger-ui:2.8.0') 编写配置类123456789101112131415161718192021222324252627282930313233343536import org.springframework.boot.autoconfigure.EnableAutoConfiguration;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;@Configuration@EnableSwagger2@EnableAutoConfiguration//项目中存在多个controller包，使用该注解@ComponentScan(basePackages = &#123;"oa.server.controller","oa.server.activiti.controller"&#125;)public class test &#123; @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select()//单个controller包可使用这个// .apis(RequestHandlerSelectors.basePackage("oa.server.controller")) .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title("OA-API-接口文档") .description("简单优雅的restfun风格") .termsOfServiceUrl("http://192.168.2.70:8081/#/oa") .version("1.0") .build(); &#125;&#125;` 注：如果项目中存在多个controller包，使用该注解 1@ComponentScan(basePackages = &#123;"oa.server.controller","oa.server.activiti.controller"&#125;) 启动项目查看swagger默认启动地址：项目地址后面加/swagger-ui.html 如：http://localhost:8081/swagger-ui.html# 查看效果]]></content>
      <categories>
        <category>Spring boot</category>
      </categories>
      <tags>
        <tag>spring boot构建 SwaggerUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决Spring boot无数据库启动失败的问题]]></title>
    <url>%2Fblog%2F327.html</url>
    <content type="text"><![CDATA[####前言遇到这种问题，基本上是因为引入了数据库相关的依赖，而配置文件中又没有配置数据库。解决的办法有两种，第一种注释掉数据库相关的依赖，第二种加入如下注解 解决办法在启动类中@SpringBootApplication注解后跟上一句话即可 123456@SpringBootApplication(exclude=&#123;DataSourceAutoConfiguration.class,HibernateJpaAutoConfiguration.class&#125;)public class Application &#123; public static void main(String[] args)&#123; SpringApplication.run(Application.class,args); &#125;&#125;]]></content>
      <categories>
        <category>Spring boot</category>
      </categories>
      <tags>
        <tag>spring boot禁止自动注入数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编写Dockerfile发布Spring boot项目]]></title>
    <url>%2Fblog%2F271.html</url>
    <content type="text"><![CDATA[前言在公司写了两个月的oa项目，要上线初步测试，需要提供一个spring boot的docker镜像和前端整合，于是 查阅资料编写了一个dockerfile 现将步骤记录于此，方便自己，也希望能帮助其他人 在服务器上创建一个文件夹，将jar包和资源文件上传到该文件夹下 在该文件夹下新建一个Docker文件 由于开发环境和生产环境的所使用的数据库是不一样的，所以在这里我指定了一个外部配置文件 编写Dockerfile12345678910111213#基于镜像FROM azul/zulu-openjdk:8#创建一个放资源目录的文件夹VOLUME /etc/resources#将打包好的jar包添加到容器根目录ADD netbank.jar app.jar#将资源文件添加的资源文件夹ADD application.properties /etc/resources/application.propertiesRUN bash -c &apos;touch /app.jar&apos;#端口设置EXPOSE 8080#启动命令 --指定了外部application.propertiesCMD [&quot;java&quot;,&quot;-Dspring.config.location=/etc/resources/application.properties&quot;,&quot;-jar&quot;,&quot;app.jar&quot;] 使用xshell或其他工具，定位到该目录 执行命令，生成镜像12docker build ./ -t springboot:1.0dcoker images -查看镜像 ./ 表明从当前路径中寻找Dockerfile文件 1docker run --name 容器名 -p 8080:8080 -itd 镜像id 进入容器配置配置资源文件 参考: https://www.zhengjie.me/blog/233.html 参考资料Dockerfile详解: https://www.cnblogs.com/sorex/p/6481407.html]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>编写Dockerfile发布spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在docker容器中使用mysql]]></title>
    <url>%2Fblog%2F237.html</url>
    <content type="text"><![CDATA[步骤1234docker pull mysql 拉取官方镜像docker run --name mysql -p 3307:3306 -e MYSQL_ROOT_PASSWORD=123456 -itd 镜像id-e MYSQL_ROOT_PASSWORD=123456 设置密码i是交互式操作，t是一个终端，d指的是在后台运行 运行后查看进入该容器启动mysql服务12docker exec -it mysql bashservice mysql start 设置允许在远程任何计算机上登录12GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;密码&apos; WITH GRANT OPTION;设置成功后原密码也会改变]]></content>
      <categories>
        <category>docker</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>docker容器使用mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于centos的docker安装与卸载]]></title>
    <url>%2Fblog%2F232.html</url>
    <content type="text"><![CDATA[前提条件 系统内核需要大于3.10 uname -r 最好确保yum为最新 yum update 开始安装123yum install docker-io 或者 yum install docker-engine --安装dockersystemctl start docker.service --启动docker服务systemctl enable docker --设置开机自启 卸载docker123456789列出所有docker安装包：yum list installed | grep docker[root@admin ~]# yum list installed | grep dockerdocker.x86_64 2:1.12.6-71.git3e8e77d.el7.centos.1 @extrasdocker-client.x86_64 2:1.12.6-71.git3e8e77d.el7.centos.1 @extrasdocker-common.x86_64 2:1.12.6-71.git3e8e77d.el7.centos.1 @extras删除所有安装包[root@admin ~]# yum -y remove docker-common.x86_64删除所有镜像容器等[root@admin ~]# rm -rf /var/lib/docker 其他docker操作参考实例 在docker中使用tomcat发布web项目Windows下安装docker： https://www.linuxidc.com/Linux/2016-07/133506.htm]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker安装，docker卸载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MYSQL:开启远程访问权限]]></title>
    <url>%2Fblog%2F169.html</url>
    <content type="text"><![CDATA[登录mysql mysql -u root -ppassword 授权为在任何主机上都能远程登录mysql mysql -u root -p grant all privileges on . to ‘root‘@’%’ identified by ‘password’ with grant option; 重新刷新权限 flush privileges; exit; #退出 参考地址http://www.linuxidc.com/Linux/2013-06/86459.htm]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>mysql配置远程访问</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git生成ssh keys步骤与使用]]></title>
    <url>%2Fblog%2F64.html</url>
    <content type="text"><![CDATA[前言SSH key 可以让你在你的电脑和Code服务器之间建立安全的加密连接。 打开Git Bash 具体操作查看本地是否存在公钥1cat ~/.ssh/id_rsa.pub 如果你看到一串字符就可以跳过生成公钥的步骤，如果没有出现，则需要使用下面的命令生成公钥。 生成公钥1ssh-keygen -t rsa -C &quot;youremail&quot; 执行后会在本地创建一个.ssh的文件夹 复制公钥打开文件直接复制 或者使用命令 1clip &lt; ~/.ssh/id_rsa.pub #复制到剪贴板 添加公钥到相应的Code服务器上。 阿里云代码托管平台 选择profile–&gt; SSH key–ADD SSH KEYgithub 选择右上角头像–\setings–&gt; SSH and GPG keys]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git，git生成ssh key，git入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用命令]]></title>
    <url>%2Fblog%2F21.html</url>
    <content type="text"><![CDATA[master : 默认开发分支； origin : 默认远程版本库 初始化操作123456$ git config -global user.name &lt;name&gt; #设置提交者名字$ git config -global user.email &lt;email&gt; #设置提交者邮箱$ git config -global core.editor &lt;editor&gt; #设置默认文本编辑器$ git config -global merge.tool &lt;tool&gt; #设置解决合并冲突时差异分析工具$ git config -list #检查已有的配置信息 创建新版本库12$ git clone &lt;url&gt; #克隆远程版本库$ git init #初始化本地版本库 修改和提交123456789$ git add . #添加所有改动过的文件$ git add &lt;file&gt; #添加指定的文件$ git mv &lt;old&gt; &lt;new&gt; #文件重命名$ git rm &lt;file&gt; #删除文件$ git rm -cached &lt;file&gt; #停止跟踪文件但不删除$ git commit -m &lt;file&gt; #提交指定文件$ git commit -m “commit message” #提交所有更新过的文件$ git commit -amend #修改最后一次提交$ git commit -C HEAD -a -amend #增补提交（不会产生新的提交历史纪录） 查看提交历史123456789$ git log #查看提交历史$ git log -p &lt;file&gt; #查看指定文件的提交历史$ git blame &lt;file&gt; #以列表方式查看指定文件的提交历史$ gitk #查看当前分支历史纪录$ gitk &lt;branch&gt; #查看某分支历史纪录$ gitk --all #查看所有分支历史纪录$ git branch -v #每个分支最后的提交$ git status #查看当前状态$ git diff #查看变更内容 撤消操作12$ git reset -hard HEAD #撤消工作目录中所有未提交文件的修改内容$ git checkout HEAD &lt;file1&gt; &lt;file2&gt; #撤消指定的未提交文件的 修改内容12$ git checkout HEAD. #撤消所有文件$ git revert &lt;commit&gt; #撤消指定的提交 分支与标签1234567$ git branch #显示所有本地分支$ git checkout &lt;branch/tagname&gt; #切换到指定分支或标签$ git branch &lt;new-branch&gt; #创建新分支$ git branch -d &lt;branch&gt; #删除本地分支$ git tag #列出所有本地标签$ git tag &lt;tagname&gt; #基于最新提交创建标签$ git tag -d &lt;tagname&gt; #删除标签 合并与衍合12$ git merge &lt;branch&gt; #合并指定分支到当前分支$ git rebase &lt;branch&gt; #衍合指定分支到当前分支 远程操作12345678$ git remote -v #查看远程版本库信息$ git remote show &lt;remote&gt; #查看指定远程版本库信息$ git remote add &lt;remote&gt; &lt;url&gt; #添加远程版本库$ git fetch &lt;remote&gt; #从远程库获取代码$ git pull &lt;remote&gt; &lt;branch&gt; #下载代码及快速合并$ git push &lt;remote&gt; &lt;branch&gt; #上传代码及快速合并$ git push &lt;remote&gt; : &lt;branch&gt;/&lt;tagname&gt; #删除远程分支或标签$ git push -tags #上传所有标签]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git命令，git入门</tag>
      </tags>
  </entry>
</search>
